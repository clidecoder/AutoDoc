#!/bin/sh

# Configuration
MAIN_BRANCH="main" # or "master"
ENABLE_ON_ALL_BRANCHES=false # Set to true to run on all branches
CLAUDE_TIMEOUT=60 # seconds
MAX_RETRIES=2

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to log with timestamp
log() {
    echo "${GREEN}[$(date '+%H:%M:%S')] $1${NC}"
}

log_error() {
    echo "${RED}[$(date '+%H:%M:%S')] ERROR: $1${NC}"
}

log_warning() {
    echo "${YELLOW}[$(date '+%H:%M:%S')] WARNING: $1${NC}"
}

# Function to call Claude with timeout and retry
call_claude() {
    local prompt="$1"
    local output_file="$2"
    local description="$3"
    local retries=0
    
    log "Calling Claude for: $description"
    
    while [ $retries -lt $MAX_RETRIES ]; do
        if timeout $CLAUDE_TIMEOUT claude -p "$prompt" > "$output_file" 2>/dev/null; then
            if [ -s "$output_file" ]; then
                log "✓ Claude call successful: $description"
                return 0
            else
                log_warning "Claude returned empty response for: $description"
            fi
        else
            retries=$((retries + 1))
            log_warning "Claude call timed out/failed (attempt $retries/$MAX_RETRIES): $description"
            
            if [ $retries -lt $MAX_RETRIES ]; then
                log "Retrying in 2 seconds..."
                sleep 2
            fi
        fi
    done
    
    log_error "All Claude attempts failed for: $description"
    return 1
}

# Function to extract current version from package.json or VERSION file
get_current_version() {
    if [ -f "package.json" ]; then
        grep -o '"version": *"[^"]*"' package.json | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+'
    elif [ -f "VERSION" ]; then
        cat VERSION
    else
        echo "0.0.0"
    fi
}

# Function to update version in package.json or VERSION file
update_version() {
    new_version=$1
    if [ -f "package.json" ]; then
        # Use sed to update package.json
        sed -i.bak "s/\"version\": *\"[^\"]*\"/\"version\": \"$new_version\"/" package.json && rm -f package.json.bak
    else
        echo "$new_version" > VERSION
    fi
}

# Function to create compact commit summary
create_commit_summary() {
    local commits="$1"
    local max_length=500
    
    # Truncate if too long
    if [ ${#commits} -gt $max_length ]; then
        echo "$commits" | head -c $max_length
        echo "... (truncated)"
    else
        echo "$commits"
    fi
}

while read local_ref local_sha remote_ref remote_sha
do
    # Extract branch name
    branch_name=$(git rev-parse --abbrev-ref HEAD)
    
    # Check if we should run on this branch
    if [ "$ENABLE_ON_ALL_BRANCHES" = false ] && [ "$branch_name" != "$MAIN_BRANCH" ]; then
        log_warning "Skipping documentation update on branch: $branch_name"
        continue
    fi
    
    # Run Biome checks if available
    if [ -f "package.json" ] && [ -f "biome.json" ]; then
        log "Running Biome checks..."
        
        # Check if npm script exists
        if npm run | grep -q "check"; then
            if npm run check; then
                log "✓ Biome checks passed"
            else
                log_error "Biome checks failed"
                echo "${YELLOW}Run 'npm run fix' to auto-fix issues or fix manually${NC}"
                exit 1
            fi
        elif command -v biome >/dev/null 2>&1; then
            # Fallback to direct biome command
            if biome check .; then
                log "✓ Biome checks passed"
            else
                log_error "Biome checks failed"
                echo "${YELLOW}Run 'biome check --write .' to auto-fix issues${NC}"
                exit 1
            fi
        else
            log_warning "Biome not available, skipping checks"
        fi
    fi
    
    # Determine commit range
    if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
        # New branch
        range="origin/$MAIN_BRANCH..HEAD"
    else
        # Existing branch
        range="$remote_sha..$local_sha"
    fi
    
    # Check if this is a tag push
    is_tag_push=false
    if expr "$local_ref" : "refs/tags/" >/dev/null; then
        is_tag_push=true
        tag_name=$(basename "$local_ref")
    fi
    
    # Gather information
    log "Analyzing commits for documentation update..."
    
    # Get all changes
    changes=$(git diff --name-status $range | head -10)
    
    # Get commits with conventional commit parsing (limit to recent commits)
    commits_raw=$(git log --pretty=format:"%s" $range | head -5)
    
    # Parse commits by type (simplified)
    feat_commits=""
    fix_commits=""
    breaking_commits=""
    docs_commits=""
    other_commits=""
    
    # Analyze each commit with simpler logic
    echo "$commits_raw" | while IFS= read -r subject; do
        # Skip empty lines
        [ -z "$subject" ] && continue
        
        # Extract commit type and check for breaking changes
        case "$subject" in
            feat:*|feat\(*\):*)
                feat_commits="${feat_commits}- ${subject}\n" ;;
            fix:*|fix\(*\):*)
                fix_commits="${fix_commits}- ${subject}\n" ;;
            docs:*|docs\(*\):*)
                docs_commits="${docs_commits}- ${subject}\n" ;;
            *)
                other_commits="${other_commits}- ${subject}\n" ;;
        esac
        
        # Check for breaking changes
        if echo "$subject" | grep -q "!:" || echo "$subject" | grep -q "BREAKING CHANGE"; then
            breaking_commits="${breaking_commits}- ${subject}\n"
        fi
    done
    
    # Re-read the variables (shell subshell issue workaround)
    feat_commits=$(echo "$commits_raw" | grep "^feat" | head -3 | sed 's/^/- /' || echo "")
    fix_commits=$(echo "$commits_raw" | grep "^fix" | head -3 | sed 's/^/- /' || echo "")
    docs_commits=$(echo "$commits_raw" | grep "^docs" | head -3 | sed 's/^/- /' || echo "")
    breaking_commits=$(echo "$commits_raw" | grep -E "!:|BREAKING CHANGE" | head -2 | sed 's/^/- /' || echo "")
    other_commits=$(echo "$commits_raw" | grep -v -E "^(feat|fix|docs)" | head -2 | sed 's/^/- /' || echo "")
    
    # Get current version
    current_version=$(get_current_version)
    
    # Prepare compact commit categorization
    commit_summary=$(create_commit_summary "Recent changes:
${feat_commits}${fix_commits}${docs_commits}${other_commits}")
    
    # Determine version bump with simplified Claude call
    log "Analyzing version bump..."
    version_prompt="Analyze these commits for semantic versioning. Reply with ONLY: major, minor, patch, or none

Current version: $current_version
Changes: $commit_summary

Rules: breaking change=major, new feature=minor, bugfix=patch, docs/chore=none"
    
    if call_claude "$version_prompt" "version.tmp" "version analysis"; then
        version_analysis=$(cat version.tmp | tr -d '\n' | tr -d ' ')
        rm -f version.tmp
    else
        log_warning "Version analysis failed, defaulting to patch"
        version_analysis="patch"
    fi
    
    # Calculate new version
    major=$(echo "$current_version" | cut -d. -f1)
    minor=$(echo "$current_version" | cut -d. -f2)
    patch=$(echo "$current_version" | cut -d. -f3)
    
    case "$version_analysis" in
        "major")
            new_version="$((major + 1)).0.0"
            ;;
        "minor")
            new_version="$major.$((minor + 1)).0"
            ;;
        "patch")
            new_version="$major.$minor.$((patch + 1))"
            ;;
        *)
            new_version="$current_version"
            ;;
    esac
    
    log "Version: $current_version → $new_version"
    
    # Update documentation files with batch processing
    docs_updated=false
    
    # Update CLAUDE.md (simplified)
    if [ -f "CLAUDE.md" ]; then
        claude_prompt="Update CLAUDE.md with these recent changes:
        
Version: $new_version
Changes: $commit_summary

Keep existing structure, add relevant updates. Be concise."
        
        if call_claude "$claude_prompt" "CLAUDE.md.tmp" "CLAUDE.md update"; then
            if [ -f "CLAUDE.md.tmp" ] && ! cmp -s CLAUDE.md CLAUDE.md.tmp 2>/dev/null; then
                mv CLAUDE.md.tmp CLAUDE.md
                git add CLAUDE.md
                docs_updated=true
                log "✓ CLAUDE.md updated"
            else
                rm -f CLAUDE.md.tmp
            fi
        else
            log_warning "CLAUDE.md update failed, skipping"
            rm -f CLAUDE.md.tmp
        fi
    fi
    
    # Update CHANGELOG.md (simplified)
    changelog_prompt="Add entry to CHANGELOG.md:

Version: $new_version (from $current_version)
Date: $(date +%Y-%m-%d)
Changes: $commit_summary

Current changelog:
$(head -20 CHANGELOG.md 2>/dev/null)

Add new entry following Keep a Changelog format. Be concise."
    
    if call_claude "$changelog_prompt" "CHANGELOG.md.tmp" "CHANGELOG update"; then
        if [ -f "CHANGELOG.md.tmp" ] && ! cmp -s CHANGELOG.md CHANGELOG.md.tmp 2>/dev/null; then
            mv CHANGELOG.md.tmp CHANGELOG.md
            git add CHANGELOG.md
            docs_updated=true
            log "✓ CHANGELOG.md updated"
        else
            rm -f CHANGELOG.md.tmp
        fi
    else
        log_warning "CHANGELOG.md update failed, skipping"
        rm -f CHANGELOG.md.tmp
    fi
    
    # Update README.md (simplified)
    if [ -f "README.md" ]; then
        readme_prompt="Update README.md for version $new_version:

Recent changes: $commit_summary
Project files: $(find . -maxdepth 1 -name "*.json" -o -name "*.js" -o -name "*.md" | head -5)

Current README (first 10 lines):
$(head -10 README.md)

Update version numbers and add any relevant changes. Keep it concise."
        
        if call_claude "$readme_prompt" "README.md.tmp" "README update"; then
            if [ -f "README.md.tmp" ] && ! cmp -s README.md README.md.tmp 2>/dev/null; then
                mv README.md.tmp README.md
                git add README.md
                docs_updated=true
                log "✓ README.md updated"
            else
                rm -f README.md.tmp
            fi
        else
            log_warning "README.md update failed, skipping"
            rm -f README.md.tmp
        fi
    else
        # Create new README
        new_readme_prompt="Create README.md for AutoDoc project version $new_version:

Recent development: $commit_summary
Files: $(ls *.json *.js *.md 2>/dev/null | head -5)

Create concise README with title, description, installation, usage. Professional but brief."
        
        if call_claude "$new_readme_prompt" "README.md.tmp" "README creation"; then
            if [ -s "README.md.tmp" ]; then
                mv README.md.tmp README.md
                git add README.md
                docs_updated=true
                log "✓ README.md created"
            else
                rm -f README.md.tmp
            fi
        else
            log_warning "README.md creation failed, skipping"
            rm -f README.md.tmp
        fi
    fi
    
    # Update version if it changed
    if [ "$new_version" != "$current_version" ] && [ "$version_analysis" != "none" ]; then
        update_version "$new_version"
        git add package.json VERSION 2>/dev/null
        docs_updated=true
        log "✓ Version bumped to $new_version"
    fi
    
    # Generate release notes if this is a tag push
    if [ "$is_tag_push" = true ]; then
        log "Generating release notes for tag: $tag_name"
        release_prompt="Generate release notes for $tag_name:
        
Changes: $commit_summary

Create concise release notes highlighting key features, fixes, and breaking changes."
        
        if call_claude "$release_prompt" "RELEASE_NOTES.md" "release notes"; then
            git add RELEASE_NOTES.md
            docs_updated=true
            log "✓ Release notes generated"
        else
            log_warning "Release notes generation failed"
        fi
    fi
    
    # Commit changes if any
    if [ "$docs_updated" = true ]; then
        # Create commit message
        commit_msg="docs: auto-update documentation and version

- Updated documentation for version $new_version
- Changes: $(echo "$commit_summary" | head -c 100)..."
        
        if [ "$is_tag_push" = true ]; then
            commit_msg="$commit_msg
- Generated release notes for $tag_name"
        fi
        
        git commit -m "$commit_msg" --no-verify
        log "✅ Documentation updated and committed"
    else
        log_warning "No documentation changes made"
    fi
    
    # Clean up any remaining temp files
    rm -f *.tmp
    
done

# Final message
log "Ready to push with updated documentation!"